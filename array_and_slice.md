# 数组和切片

## 数组

在 go 中，数组的声明需要指定一个长度和类型，一旦声明， 则数组的长度和类型就不可变了，这与 js 有很大的不同，意味着一个数组里面不能有不同类型的值，且不能做类似 push 数组的操作。

```go
var arr [3]int = [3]int{1, 1, 1}     // 长度为3，类型为int的数组
var arr1 [4]int                      // 声明未赋值， 默认为类型的零值 [0 0 0 0]
arr2 := [4]int{2, 5}                 // [2 5 0 0]
arr3 := [4]int{1, 3: 10}             // [1 0 0 10] 指定下标3的值为10
arr4 := [...]int{1, 2, 3, 4, 99: 20} // [...]表示由后面的值推断数组的长度， 这里最长的下标是99，所以这里数组长度是100
fmt.Println(arr, arr1, arr2, arr3, arr4)
```

多维数组：

```go
a := [2][2]int{
    {1,1},
    {1,1},
} // 二维数组 [[1 1] [1 1]]


b:=[2][3][4]int{
    {
        {0,2,3,4},
        {1,2,4,5},
        {2,2,3,2},
    },
    {
        {0,2,3,4},
        {1,2,4,5},
        {2,2,3,2},
    }
} //三维数组 [[[0 2 3 4] [1 2 4 5] [2 2 3 2]] [[0 2 3 4] [1 2 4 5] [2 2 3 2]]]

```

可以将数组当做参数传入`len`函数，则会返回数组的第一维长度

jser 学习数组，往往会感到困惑，在 js 中，类似 `[1, 2, 3]` 和 `[1, 2, 8]`，我们会把他们称之为数组类型，虽然他们不相等，但是类型却是一样的， 在 go 中不这么认为，两个长度不相等的数组，他们是不同的类型。

长度类型一致，并且元素一致的数组，它们相等

```go
	a := [3]int{1, 1, 1}
	b := [3]int{1, 1, 1}
	fmt.Println(a == b) // true
```

同时，go 中的数组是一个值类型，就是说，你将数组赋值给另一个数组或者将数组当函数的参数传递时，底层操作是一个值的拷贝，而不是传递的引用。

```go
func test(arr [3]string) {
	arr[0] = "different_array"
	fmt.Println(arr) // [different_array in go]
}
var eg [3]string = [3]string{"array", "in", "go"}
test(eg)
fmt.Println(eg) // [array in go]
```
